1-(1-0.95)/2
CI.prob <- 0.05
(1-CI.prob)/2
CI.prob <- 0.95
(1-CI.prob)/2
prob.low.var <- 0.01
min((1-CI.prob)/2, 0.01)
1-(1-CI.prob)/2
1-min((1-CI.prob)/2, prob.low.var)
1-min((1-CI.prob)/2, 0.005)
(1-CI.prob)/2
min((1-CI.prob)/2, prob.low.var)
1-min((1-CI.prob)/2, prob.low.var)
(1-CI.prob)/2
min(CI.prob/2, CI.prob-prob.low.var)
min(CI.prob/2, prob.low.var)
max(CI.prob, prob.low.var)
(1-CI.prob)
(1-CI.prob) - min((1-CI.prob)/2, prob.low.var)
prob.low.var <- 0.5
(1-CI.prob) - min((1-CI.prob)/2, prob.low.var)
prob.low.var <- 0.10
(1-CI.prob) - min((1-CI.prob)/2, prob.low.var)
prob.low.var <- 0.01
(1-CI.prob) - min((1-CI.prob)/2, prob.low.var)
prob.low.var <- 0.005
(1-CI.prob) - min((1-CI.prob)/2, prob.low.var)
#### A quick implementation of the heritability confidence intervals algorithms
#### to be used when kinship matrix is the only correlation matrix between individuals
#### (other matrices can be used as well)
#### This function receives a list of "prep.dat" that is either the output of the function prepareDataForHeritabilityEst
#### or the function prepareDataForHeritabilityEst.META. The later function pepare data from multiple studies.
heritability.CI <- function(prep.dat, CI.prob= 0.95, prob.eps = 0.01, end.point.eps = 1e-3){
if (CI.prob > 1) stop("Confidence intervals probability should be smaller than 1")
if (CI.prob <= 0) stop("Confidence intervals probability cannot be zero or less")
lambda.0 <- prep.dat$lambda.0
kappa <- prep.dat$kappa
kinship.var <- prep.dat$kinship.var
error.var <- prep.dat$error.var
n <- length(lambda.0)
total.var <- kinship.var + error.var
calc.surv.for.const <- function(const){
cur.lambda <- (lambda.0*(lambda.0*kinship.var + error.var + kinship.var))/kappa - const*(lambda.0*kinship.var + kinship.var + error.var)/n
if (all(cur.lambda < 0)) surv <- 1
if (all(cur.lambda > 0)) surv <- 0
saddlepoint <- findSaddlePoint(cur.lambda)
z.hat <- calc.z.hat(cur.lambda, saddlepoint )
zeta.hat <- calc.zeta.hat(cur.lambda, saddlepoint )
surv <- 1 - pnorm(zeta.hat) + dnorm(zeta.hat)*(1/z.hat - 1/zeta.hat)
return(surv)
}
if (kinship.var == 0){
low.CI.prob <- 0
high.CI.prob <- (1-CI.prob)
low.CI.val <- 0
########  binary search for high.CI point
val.low <- 0 ; surv.low <- 1
val.high <- 1; surv.high <- 0
val.mid <- (val.high + val.low)/2 ; surv.mid  <- calc.surv.for.const(val.mid)
while (abs(surv.mid - high.CI.prob) > prob.eps & abs(val.mid - val.low) > end.point.eps & abs(val.mid - val.high) > end.point.eps) {
if (surv.mid > high.CI.prob){
val.low <- val.mid; surv.low <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- calc.surv.for.const(val.mid)
} else{ # surv.mid < low.CI.prob
val.high <- val.mid; surv.high <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- pmax(0, calc.surv.for.const(val.mid))
}
if (val.high == val.low) break
}
high.CI.val <- val.mid
} else{
low.CI.prob <- 1-(1-CI.prob)/2
high.CI.prob <- (1-CI.prob)/2
########  binary search for low.CI point
val.low <- 0 ; surv.low <- 1
val.high <- 1; surv.high <- 0
val.mid <- (val.high + val.low)/2 ; surv.mid <- calc.surv.for.const(val.mid)
while (abs(surv.mid - low.CI.prob) > prob.eps & abs(val.mid - val.low) > end.point.eps & abs(val.mid - val.high) > end.point.eps) {
if (surv.mid > low.CI.prob){
val.low <- val.mid; surv.low <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- calc.surv.for.const(val.mid)
} else{ # surv.mid < low.CI.prob
val.high <- val.mid; surv.high <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- calc.surv.for.const(val.mid)
}
if (val.high == val.low) break
}
low.CI.val <- val.mid
########  binary search for high.CI point
val.low <- 0 ; surv.low <- 1
val.high <- 1; surv.high <- 0
val.mid <- (val.high + val.low)/2 ; surv.mid  <- calc.surv.for.const(val.mid)
while (abs(surv.mid - high.CI.prob) > prob.eps & abs(val.mid - val.low) > end.point.eps & abs(val.mid - val.high) > end.point.eps) {
if (surv.mid > high.CI.prob){
val.low <- val.mid; surv.low <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- calc.surv.for.const(val.mid)
} else{ # surv.mid < low.CI.prob
val.high <- val.mid; surv.high <- surv.mid
val.mid <- (val.high + val.low)/2 ; surv.mid <- pmax(0, calc.surv.for.const(val.mid))
}
if (val.high == val.low) break
}
high.CI.val <- val.mid
}
CI <- c(low.CI.val, high.CI.val)
return(list(CI = CI, CI.prob = CI.prob))
}
rownames(vc.est.new) <- c("error", names.cov.mat )
source("~/Documents/GitHub/Heritability_CIs/TSofer_varComp_CI_functions.R")
require(CompQuadForm)
source("~/Documents/GitHub/Heritability_CIs/TSofer_varComp_CI_functions.R")
source("~/Documents/GitHub/Heritability_CIs/Dev_heritability_CI_when_zero_heritability.R")
sim.dir <- ""
require(GWASTools)
n <- 3000 ## or whatever n you want!
## from setting 2 in the supplementary material
grm.family <- matrix(c(1, 0.05, 0.05, 0.05, 1, 0.1, 0.05, 0.1, 1), nrow = 3)
## from setting 1 in the supplementary material
grm.family <- matrix(c(1, 0.4, 0.5, 0.4, 1, 0.6, 0.5, 0.6, 1), nrow = 3)
house.family <- matrix(c(1,1,1,1,1,1, 1,1,1), nrow = 3)
grm <- matrix(0, nrow = n, ncol = n)
hh.mat <- matrix(0, nrow = n, ncol = n)
n.family <- n/3
n.in.family <- 3
for (i in 1:n.family){
inds.family <- ((i-1)*n.in.family + 1):(i*n.in.family)
grm[inds.family,inds.family] <- grm.family
hh.mat[inds.family,inds.family] <- house.family
}
colnames(grm) <- rownames(grm) <- colnames(hh.mat) <- rownames(hh.mat) <- paste0("p", 1:n)
covMatList <- list(grm = grm, hh = hh.mat)
varComp <- c(40, 15, 100)
covMat <- covMatList[[1]]*varComp[1] + covMatList[[2]]*varComp[2] + diag(n)*varComp[3]
svd.covMat <- svd(covMat)
sqrt.covMat <- svd.covMat$v %*% diag(sqrt(svd.covMat$d)) %*% t(svd.covMat$v)
dat <- data.frame(scanID = rownames(grm), EV1 = rnorm(n), stringsAsFactors = FALSE)
scanAnnot <- ScanAnnotationDataFrame(dat)
output.folder <- paste0(sim.dir, "/output/")
covMatList <- getobj(paste0(sim.dir, "/simulated_data/covMatList.RData"))
sqrt.covMat <- getobj((paste0(sim.dir, "simulated_data/sqrt_covMat.RData"))
scans.scanAnnot <- pData(scanAnnot)$scanID
i <-1
ind.err <- rnorm(nrow(covMatList[[1]]))
err <- sqrt.covMat %*% ind.err
rownames(err) <- rownames(covMatList[[1]])
X <- cbind(rep(1, length(err)), scanAnnot$EV1)
y <- err + X %*% beta
